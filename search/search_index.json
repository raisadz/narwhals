{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Narwhals","text":"<p>Extremely lightweight compatibility layer between pandas and Polars:</p> <ul> <li>\u2705 No dependencies.</li> <li>\u2705 Lightweight: wheel is smaller than 30 kB.</li> <li>\u2705 Simple, minimal, and predictable.</li> </ul> <p>No need to choose - support both with ease!</p>"},{"location":"#whos-this-for","title":"Who's this for?","text":"<p>Anyone wishing to write a library/application/service which consumes dataframes, and wishing to make it completely dataframe-agnostic.</p>"},{"location":"#lets-get-started","title":"Let's get started!","text":"<ul> <li>Installation</li> <li>Quick start</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>First, make sure you have created and activated a Python3.8+ virtual environment.</p> <p>Then, run <pre><code>python -m pip install narwhals\n</code></pre></p> <p>Then, if you start the Python REPL and see the following: <pre><code>&gt;&gt;&gt; import narwhals\n&gt;&gt;&gt; narwhals\n'0.4.1'\n</code></pre> then installation worked correctly!</p>"},{"location":"quick_start/","title":"Quick start","text":""},{"location":"quick_start/#prerequisites","title":"Prerequisites","text":"<p>Please start by following the installation instructions</p> <p>Then, please install the following:</p> <ul> <li>pandas</li> <li>Polars</li> </ul>"},{"location":"quick_start/#simple-example","title":"Simple example","text":"<p>Create a Python file <code>t.py</code> with the following content:</p> <pre><code>import pandas as pd\nimport polars as pl\nimport narwhals as nw\n\n\ndef my_function(df_any):\n    df = nw.DataFrame(df_any)\n    column_names = df.column_names\n    return column_names\n\n\ndf_pandas = pd.DataFrame({'a': [1, 2, 3], 'b': [4, 5, 6]})\ndf_polars = pl.DataFrame({'a': [1, 2, 3], 'b': [4, 5, 6]})\n\nprint('pandas result: ', my_function(df_pandas))\nprint('Polars result: ', my_function(df_polars))\n</code></pre> <p>If you run <code>python t.py</code> and your output looks like this: <pre><code>pandas result: ['a', 'b']\nPolars result: ['a', 'b']\n</code></pre></p> <p>then all your installations worked perfectly.</p> <p>Let's learn about what you just did, and what Narwhals can do for you.</p>"},{"location":"reference/","title":"Reference","text":"<p>Here are some related projects.</p>"},{"location":"reference/#dataframe-interchange-protocol","title":"Dataframe Interchange Protocol","text":"<p>Standardised way of interchanging data between libraries, see here.</p>"},{"location":"reference/#array-api","title":"Array API","text":"<p>Array counterpart to the DataFrame API, see here.</p>"},{"location":"basics/column/","title":"Column","text":"<p>In dataframe.md, you learned how to write a dataframe-agnostic function.</p> <p>We only used DataFrame methods there - but what if we need to operate on its columns?</p>"},{"location":"basics/column/#extracting-a-column","title":"Extracting a column","text":""},{"location":"basics/column/#example-1-filter-based-on-a-columns-values","title":"Example 1: filter based on a column's values","text":"<pre><code>import narwhals as nw\n\ndef my_func(df):\n    df_s = nw.DataFrame(df)\n    df_s = df_s.filter(nw.col('a') &gt; 0)\n    return nw.to_native(df_s)\n</code></pre> pandasPolars <p><pre><code>import pandas as pd\n\ndf = pd.DataFrame({'a': [-1, 1, 3], 'b': [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>   a  b\n0  1  5\n1  3 -3\n</code></pre> </p> <p><pre><code>import polars as pl\n\ndf = pl.DataFrame({'a': [-1, 1, 3], 'b': [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>shape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 5   \u2502\n\u2502 3   \u2506 -3  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> </p>"},{"location":"basics/column/#example-2-multiply-a-columns-values-by-a-constant","title":"Example 2: multiply a column's values by a constant","text":"<p>Let's write a dataframe-agnostic function which multiplies the values in column <code>'a'</code> by 2.</p> <pre><code>import narwhals as nw\n\ndef my_func(df):\n    df_s = nw.DataFrame(df)\n    df_s = df_s.with_columns(nw.col('a')*2)\n    return nw.to_native(df_s)\n</code></pre> pandasPolars <p><pre><code>import pandas as pd\n\ndf = pd.DataFrame({'a': [-1, 1, 3], 'b': [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>   a  b\n0 -2  3\n1  2  5\n2  6 -3\n</code></pre> </p> <p><pre><code>import polars as pl\n\ndf = pl.DataFrame({'a': [-1, 1, 3], 'b': [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>shape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 -2  \u2506 3   \u2502\n\u2502 2   \u2506 5   \u2502\n\u2502 6   \u2506 -3  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> </p> <p>Note that column <code>'a'</code> was overwritten. If we had wanted to add a new column called <code>'c'</code> containing column <code>'a'</code>'s values multiplied by 2, we could have used <code>Column.rename</code>:</p> <pre><code>import narwhals as nw\n\ndef my_func(df):\n    df_s = nw.DataFrame(df)\n    df_s = df_s.with_columns((nw.col('a')*2).alias('c'))\n    return nw.to_native(df_s)\n</code></pre> pandasPolars <p><pre><code>import pandas as pd\n\ndf = pd.DataFrame({'a': [-1, 1, 3], 'b': [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>   a  b  c\n0 -1  3 -2\n1  1  5  2\n2  3 -3  6\n</code></pre> </p> <p><pre><code>import polars as pl\n\ndf = pl.DataFrame({'a': [-1, 1, 3], 'b': [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>shape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 c   \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 -1  \u2506 3   \u2506 -2  \u2502\n\u2502 1   \u2506 5   \u2506 2   \u2502\n\u2502 3   \u2506 -3  \u2506 6   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> </p>"},{"location":"basics/complete_example/","title":"Complete example","text":"<p>We're going to write a dataframe-agnostic \"Standard Scaler\". This class will have <code>fit</code> and <code>transform</code> methods (like <code>scikit-learn</code> transformers), and will work agnosstically for pandas and Polars.</p> <p>We'll need to write two methods:</p> <ul> <li><code>fit</code>: find the mean and standard deviation for each column from a given training set;</li> <li><code>transform</code>: scale a given dataset with the mean and standard deviations calculated   during <code>fit</code>.</li> </ul> <p>The <code>fit</code> method is a bit complicated, so let's start with <code>transform</code>. Suppose we've already calculated the mean and standard deviation of each column, and have stored them in attributes <code>self.means</code> and <code>self.std_devs</code>.</p>"},{"location":"basics/complete_example/#transform-method","title":"Transform method","text":"<p>The general strategy will be:</p> <ol> <li>Initialise a Narwhals DataFrame by passing your dataframe to <code>nw.DataFrame</code>.</li> <li>Express your logic using the subset of the Polars API supported by Narwhals.</li> <li>If you need to return a dataframe to the user in its original library, call <code>narwhals.to_native</code>.</li> </ol> <pre><code>import narwhals as nw\n\nclass StandardScalar:\n    def transform(self, df):\n        df = nw.DataFrame(df)\n        df = df.with_columns(\n            (nw.col(col) - self._means[col]) / self._std_devs[col]\n            for col in df.columns\n        )\n        return nw.to_native(df)\n</code></pre> <p>Note that all the calculations here can stay lazy if the underlying library permits it. For Polars, the return value is a <code>polars.LazyFrame</code> - it is the caller's responsibility to call <code>.collect()</code> on the result if they want to materialise its values.</p>"},{"location":"basics/complete_example/#fit-method","title":"Fit method","text":"<p>Unlike the <code>transform</code> method, <code>fit</code> cannot stay lazy, as we need to compute concrete values for the means and standard deviations.</p> <p>To be able to get <code>Series</code> out of our <code>DataFrame</code>, we'll need the <code>DataFrame</code> to be an eager one, as Polars doesn't have a concept of lazy <code>Series</code>. To do that, when we instantiate our <code>narwhals.DataFrame</code>, we pass <code>features=['eager']</code>, which lets us access eager-only features.</p> <pre><code>import narwhals as nw\n\nclass StandardScalar:\n    def fit(self, df):\n        df = nw.DataFrame(df, features=['eager'])\n        self._means = {df[col].mean() for col in df.columns}\n        self._std_devs = {df[col].std() for col in df.columns}\n</code></pre>"},{"location":"basics/complete_example/#putting-it-all-together","title":"Putting it all together","text":"<p>Here is our dataframe-agnostic standard scaler: <pre><code>import narwhals as nw\n\nclass StandardScaler:\n    def fit(self, df):\n        df = nw.DataFrame(df, features=[\"eager\"])\n        self._means = {col: df[col].mean() for col in df.columns}\n        self._std_devs = {col: df[col].std() for col in df.columns}\n\n    def transform(self, df):\n        df = nw.DataFrame(df)\n        df = df.with_columns(\n            (nw.col(col) - self._means[col]) / self._std_devs[col]\n            for col in df.columns\n        )\n        return nw.to_native(df)\n</code></pre></p> <p>Next, let's try running it. Notice how, as <code>transform</code> doesn't use <code>features=['lazy']</code>, we can pass a <code>polars.LazyFrame</code> to it without issues!</p> pandasPolars <p><pre><code>import pandas as pd\n\ndf_train = pd.DataFrame({'a': [1, 2, 3], 'b': [4, 5, 7]})\ndf_test = pd.DataFrame({'a': [1, 2, 3], 'b': [4, 5, 7]})\nscaler = StandardScaler()\nscaler.fit(df_train)\nprint(scaler.transform(df_test))\n</code></pre> <pre><code>     a         b\n0 -1.0 -0.872872\n1  0.0 -0.218218\n2  1.0  1.091089\n</code></pre> </p> <p><pre><code>import polars as pl\n\ndf_train = pl.DataFrame({'a': [1, 2, 3], 'b': [4, 5, 7]})\ndf_test = pl.LazyFrame({'a': [1, 2, 3], 'b': [4, 5, 7]})\nscaler = StandardScaler()\nscaler.fit(df_train)\nprint(scaler.transform(df_test).collect())\n</code></pre> <pre><code>shape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 b         \u2502\n\u2502 ---  \u2506 ---       \u2502\n\u2502 f64  \u2506 f64       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 -1.0 \u2506 -0.872872 \u2502\n\u2502 0.0  \u2506 -0.218218 \u2502\n\u2502 1.0  \u2506 1.091089  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> </p>"},{"location":"basics/dataframe/","title":"DataFrame","text":"<p>To write a dataframe-agnostic function, the steps you'll want to follow are:</p> <ol> <li>Initialise a Narwhals DataFrame by passing your dataframe to <code>nw.DataFrame</code>.</li> <li>Express your logic using the subset of the Polars API supported by Narwhals.</li> <li>If you need to return a dataframe to the user in its original library, call <code>narwhals.to_native</code>.</li> </ol> <p>Let's try writing a simple example.</p>"},{"location":"basics/dataframe/#example-1-group-by-and-mean","title":"Example 1: group-by and mean","text":"<p>Make a Python file <code>t.py</code> with the following content: <pre><code>import narwhals as nw\n\ndef func(df):\n    # 1. Create a Narwhals dataframe\n    df_s = nw.DataFrame(df)\n    # 2. Use the subset of the Polars API supported by Narwhals\n    df_s = df_s.group_by('a').agg(nw.col('b').mean())\n    # 3. Return a library from the user's original library\n    return nw.to_native(df_s)\n</code></pre> Let's try it out:</p> pandasPolars <p><pre><code>import pandas as pd\n\ndf = pd.DataFrame({'a': [1, 1, 2], 'b': [4, 5, 6]})\nprint(func(df))\n</code></pre> <pre><code>   a    b\n0  1  4.5\n1  2  6.0\n</code></pre> </p> <p><pre><code>import polars as pl\n\ndf = pl.DataFrame({'a': [1, 1, 2], 'b': [4, 5, 6]})\nprint(func(df))\n</code></pre> <pre><code>shape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 4.5 \u2502\n\u2502 2   \u2506 6.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> </p>"}]}